---
title: "TypeScriptでZustandを使ってみよう"
emoji: "⚡"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript"]
published: false
---

## 参考
https://docs.pmnd.rs/zustand/guides/typescript

このドキュメントは、ZustandのTypeScriptガイドに関するもので、以下の主要なトピックをカバーしています：

## はじめに
記事の主な内容は以下の通りです：

<!-- ##### 1. 基本的な使用法

##### 2. 型推論の問題


##### 4. ミドルウェアの使用

##### 5. スライスパターン

##### 6. バウンデッドuseStoreフック（未記入）：バニラストア用のバウンデッドuseStoreフックについて -->


## この記事の対象読者
対象読者は、Zustandを使用してステート管理を行いたいと考えているTypeScriptの開発者です。
## **Zustandの基本的な使用法**

TypeScriptでZustandを使用する際のReactとの違いは、`create(...)`の代わりに`create<T>()(...)`を記述する必要があることです。ここで、Tは状態の型を注釈するためのものです。

例えば、以下のようになります。

```tsx
import { create } from 'zustand'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}))

```
<!-- BearStateとこのコードの補足説明を追加する -->

#### **▶ なぜ単純に初期状態から型を推論できないのか？**

`create(...)`の代わりに`create<T>()(...)`を記述する必要がある理由は、結論、TypeScriptのジェネリック型Tが「**型を返すとともに型を取得する**」という性質を持っているためです。

:::message
**補足：ジェネリック型とは**
ジェネリック型はプログラミング言語の機能で、型が決まっていない、または柔軟に型を変えることができるようにする機能です。TypeScriptにおいてもジェネリック型が提供されています。

ジェネリック型は、一般的に大文字のTを使って表現されますが、これはTypeの頭文字を取っているだけで、任意の文字を使うことができます。
:::

例えば、以下に示すコードは、create関数の簡易版を示しています。

```tsx
declare const create: <T>(f: (get: () => T) => T) => T

const x = create((get) => ({
  foo: 0,
  bar: () => get(),
}))
// `x` is inferred as `unknown` instead of
// interface X {
//   foo: number,
//   bar: () => X
// }

```

このコードでは、create関数の引数fが```(get: () => T) => T```という形式をしています。これは、Tの型を"返す"とともに、getという関数を通してTの型を"取得する"ことを意味します。

しかし、TypeScriptはTが具体的にどのような型であるのか、その情報がどこから得られるのかを推論することはできません。これはTypeScriptが「卵が先か鶏が先か」というような問題につまづいてしまうことに起因します。

よって、TypeScriptはこの難問を解決できず、Tの型を不明（unknown）と判断してしまう訳です。

そのため、`create(...)`の代わりに`create<T>()(...)`を記述して開発者が型を予め指定することで、Zustandの状態管理オブジェクトの構造と、それがどのように使われるべきかをTypeScriptに伝えることを実現しています。
## **ミドルウェアの使用**

TypeScriptでのミドルウェアの利用は特別な設定を必要としません。以下の例は、`devtools`と`persist`というミドルウェアを利用しています：

```tsx
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()(
  devtools(
    persist((set) => ({
      bears: 0,
      increase: (by) => set((state) => ({ bears: state.bears + by })),
    }))
  )
)

```

ただし、TypeScriptの型推論をうまく機能させるため、create関数の直後でミドルウェアを利用することが推奨されています。もし自分でカスタムミドルウェアを作る場合は、より高度な型の管理が求められます：

```tsx
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

const myMiddlewares = (f) => devtools(persist(f))

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()(
  myMiddlewares((set) => ({
    bears: 0,
    increase: (by) => set((state) => ({ bears: state.bears + by })),
  }))
)

```

また、devtoolsミドルウェアは可能な限り最後に使用することを推奨します。例えば、immerをミドルウェアとして使用する場合、`immer(devtools(...))`とすべきであり、`devtools(immer(...))`とするべきではありません。これは`devtools`が`setState`を変更し、それに型パラメータを追加するためで、これは他のミドルウェア（例えば`immer`）が`devtools`の前に`setState`を変更すると失われる可能性があるからです。そのため、`devtools`を最後に使用することで、他のミドルウェアが`devtools`の前に`setState`を変更することがないようにします。
<!-- わかりづれえ -->

### **スライスパターン**

以下のように、状態をスライスに分割することができます。

```tsx
import { create, StateCreator } from 'zustand'

interface BearSlice {
  bears: number
  addBear: () => void
  eatFish: () => void
}
const createBearSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  BearSlice
> = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),
})

interface FishSlice {
  fishes: number
  addFish: () => void
}
const createFishSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  FishSlice
> = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
})

const useBoundStore = create<BearSlice & FishSlice>()((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
}))

```

スライスパターンについての詳細な説明は[こちら](https://github.com/pmndrs/zustand/wiki/TypeScript---Slices-Pattern)を参照してください。

以上が、指定されたリンクの内容の主要な部分の和訳です。