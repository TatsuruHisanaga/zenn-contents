---
title: "TypeScriptでZustandを使ってみよう"
emoji: "⚡"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["TypeScript", "Zustand"]
published: false
---

## 参考
https://docs.pmnd.rs/zustand/guides/typescript


## はじめに
記事の主な内容は以下の通りです：

##### 1. 基本的な使用法

##### 2. 型推論の問題


##### 4. ミドルウェアの使用

##### 5. スライスパターン

##### 6. バウンデッドuseStoreフック（未記入）：バニラストア用のバウンデッドuseStoreフックについて


## この記事の対象読者
この記事の対象読者は、Zustandを使用してステート管理を行いたいと考えているTypeScriptの学習者です。

## Zustandとは何なのか
Zustandは、JavaScriptまたはTypeScriptにおける小さくてシンプルな**状態管理ライブラリ**です。Reactと共に使うことが多いですが、それ以外の環境でも使用可能です。Zustandを利用することによって、**状態管理に関連するコードの複雑さを大幅に解消できます**。また、HookベースのAPIを提供しているため、React Hooksに慣れている開発者にとっては直感的に使うことが可能です。
## **Zustandの基本的な使用法**

TypeScriptでZustandを使用する際には、状態の型を指定するために`create<T>()(...)` の形式を使用します。この`<T>`の部分には、状態の型を表すインターフェイスや型が入ります。

:::message
**補足：インターフェイスとは**
インターフェイスは、**特定のオブジェクトが必ず持っていなければならないプロパティやメソッドの一覧を定義するための構造**です。

インターフェイスはコードの予期しない動作を防ぐための契約のようなもので、あるオブジェクトが特定のインターフェイスを実装していると宣言すると、**そのオブジェクトがそのインターフェイスのすべてのプロパティとメソッドを提供することが保証されます**。
:::

たとえば、以下のようになります。

```tsx
import { create } from 'zustand'

interface BearState {
  bears: number
  increase: (by: number) => void
}

// 以下の部分で`create`関数に`BearState`を型として渡しています
const useBearStore = create<BearState>()((set) => ({
  bears: 0,
  increase: (by) => set((state) => ({ bears: state.bears + by })),
}))

```
<!-- BearStateとこのコードの補足説明を追加する -->


`<BearState>`という記述により、このZustandストアが`BearState`という型の状態を管理することを指定しています。このため、このストアの状態やその更新関数を使用する際には、TypeScriptが型のチェックを行ってくれます。

:::message
**補足：ストアとは**
ストアとは、アプリケーションの状態を保持してその変更を監視するためのものです。これは一般的にフロントエンドのアプリケーション開発でよく使われ、特に大規模なアプリケーションや複数のコンポーネントが共有する状態を管理する際に有効です。
:::

#### **▶ なぜ単純に初期状態から型を推論できないのか？**

`create(...)`の代わりに`create<T>()(...)`を記述する必要がある理由は、結論、TypeScriptのジェネリック型Tが「**型を返すとともに型を取得する**」という性質を持っているためです。

:::message
**補足：ジェネリック型とは**
ジェネリック型はプログラミング言語の機能で、型が決まっていない、または柔軟に型を変えることができるようにする機能です。TypeScriptにおいてもジェネリック型が提供されています。

ジェネリック型は、一般的に大文字のTを使って表現されますが、これはTypeの頭文字を取っているだけで、任意の文字を使うことができます。
:::

たとえば、以下に示すコードは、create関数の簡易版を示しています。

```tsx
declare const create: <T>(f: (get: () => T) => T) => T

const x = create((get) => ({
  foo: 0,
  bar: () => get(),
}))
// このコードにおいて、xの推論される型は"unknown"になります。
// 期待する推論結果は以下のインターフェイスXに従う型です：
// interface X {
//   foo: number,
//   bar: () => X
// }

```

このコードでは、create関数の引数fが```(get: () => T) => T```という形式をしています。これは、Tの型を"返す"とともに、getという関数を通してTの型を"取得する"ことを意味します。

しかし、TypeScriptはTが具体的にどのような型であるのか、その情報がどこから得られるのかを推論することはできません。これはTypeScriptが「卵が先か鶏が先か」というような問題につまづいてしまうことに起因します。

よって、TypeScriptはこの難問を解決できず、Tの型を不明（unknown）と判断してしまう訳です。

そのため、`create(...)`の代わりに`create<T>()(...)`を記述して開発者が型をあらかじめ指定することで、Zustandの状態管理オブジェクトの構造と、それがどのように使われるべきかをTypeScriptに伝えています。
## **ミドルウェアの使用**

TypeScriptでのミドルウェアの利用は特別な設定を必要としません。以下の例は、`devtools`と`persist`というミドルウェアを利用しています：

```tsx
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()(
  devtools(
    persist((set) => ({
      bears: 0,
      increase: (by) => set((state) => ({ bears: state.bears + by })),
    }))
  )
)

```

ただし、TypeScriptの型推論をうまく機能させるため、create関数の直後でミドルウェアを利用することが推奨されています。もし自分でカスタムミドルウェアを作る場合は、より高度な型の管理が求められます：

```tsx
import { create } from 'zustand'
import { devtools, persist } from 'zustand/middleware'

const myMiddlewares = (f) => devtools(persist(f))

interface BearState {
  bears: number
  increase: (by: number) => void
}

const useBearStore = create<BearState>()(
  myMiddlewares((set) => ({
    bears: 0,
    increase: (by) => set((state) => ({ bears: state.bears + by })),
  }))
)

```

また、devtoolsミドルウェアは可能な限り最後に使用することを推奨します。例えば、immerをミドルウェアとして使用する場合、`immer(devtools(...))`とすべきであり、`devtools(immer(...))`とするべきではありません。これは`devtools`が`setState`を変更し、それに型パラメーターを追加するためで、これは他のミドルウェア（例えば`immer`）が`devtools`の前に`setState`を変更すると失われる可能性があるからです。そのため、`devtools`を最後に使用することで、他のミドルウェアが`devtools`の前に`setState`を変更することがないようにします。
<!-- わかりづれえ -->

### **スライスパターン**

このコードは、Zustandでの「スライスパターン」の例を示しています。スライスパターンは、大きな状態オブジェクトを小さな部分（"スライス"）に分割することを指します。それぞれのスライスは独自の状態と行動（アクション）を持ちます。


以下のように、状態をスライスに分割できます。

```tsx
import { create, StateCreator } from 'zustand'

interface BearSlice {
  bears: number
  addBear: () => void
  eatFish: () => void
}
const createBearSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  BearSlice
> = (set) => ({
  bears: 0,
  addBear: () => set((state) => ({ bears: state.bears + 1 })),
  eatFish: () => set((state) => ({ fishes: state.fishes - 1 })),
})

interface FishSlice {
  fishes: number
  addFish: () => void
}
const createFishSlice: StateCreator<
  BearSlice & FishSlice,
  [],
  [],
  FishSlice
> = (set) => ({
  fishes: 0,
  addFish: () => set((state) => ({ fishes: state.fishes + 1 })),
})

const useBoundStore = create<BearSlice & FishSlice>()((...a) => ({
  ...createBearSlice(...a),
  ...createFishSlice(...a),
}))

```
この例では、2つのスライス`BearSlice`と`FishSlice`が作成されています。それぞれには独自の状態（`bears`と`fishes`）と行動（`addBear`、`eatFish`、`addFish`）があります。

また、`createBearSlice`と`createFishSlice`関数がそれぞれのスライスを生成します。これらの関数は、`set`関数を引数に取り、状態を更新するための行動を定義します。

最後に、`useBoundStore`は全体の状態を生成するために`create`関数を使用します。この状態は、それぞれのスライスの状態を合成します。

これにより、アプリケーションの状態管理が容易になり、各スライスが独立して扱えるため、メンテナンス性や再利用性が向上します。また、特定のスライスだけを取り出してテストすることも可能になります。



以上が、Zustandの主要な部分のまとめです。